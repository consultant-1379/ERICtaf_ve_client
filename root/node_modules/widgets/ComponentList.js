
define('template!widgets/ComponentList/_componentList.html',['jscore/handlebars/handlebars'],function (Handlebars) { return Handlebars.template(function (Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, stack2, foundHelper, tmp1, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += "\n    ";
  foundHelper = helpers.name;
  stack1 = foundHelper || depth0.name;
  stack2 = helpers['if'];
  tmp1 = self.program(2, program2, data);
  tmp1.hash = {};
  tmp1.fn = tmp1;
  tmp1.inverse = self.noop;
  stack1 = stack2.call(depth0, stack1, tmp1);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  foundHelper = helpers.type;
  stack1 = foundHelper || depth0.type;
  stack2 = helpers['if'];
  tmp1 = self.program(5, program5, data);
  tmp1.hash = {};
  tmp1.fn = tmp1;
  tmp1.inverse = self.noop;
  stack1 = stack2.call(depth0, stack1, tmp1);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;}
function program2(depth0,data) {
  
  var buffer = "", stack1, stack2;
  buffer += "<div class=\"ebComponentList-item\" ";
  foundHelper = helpers.title;
  stack1 = foundHelper || depth0.title;
  stack2 = helpers['if'];
  tmp1 = self.program(3, program3, data);
  tmp1.hash = {};
  tmp1.fn = tmp1;
  tmp1.inverse = self.noop;
  stack1 = stack2.call(depth0, stack1, tmp1);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">";
  foundHelper = helpers.name;
  stack1 = foundHelper || depth0.name;
  if(typeof stack1 === functionType) { stack1 = stack1.call(depth0, { hash: {} }); }
  else if(stack1=== undef) { stack1 = helperMissing.call(depth0, "name", { hash: {} }); }
  buffer += escapeExpression(stack1) + "</div>";
  return buffer;}
function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " title=\"";
  foundHelper = helpers.title;
  stack1 = foundHelper || depth0.title;
  if(typeof stack1 === functionType) { stack1 = stack1.call(depth0, { hash: {} }); }
  else if(stack1=== undef) { stack1 = helperMissing.call(depth0, "title", { hash: {} }); }
  buffer += escapeExpression(stack1) + "\"";
  return buffer;}

function program5(depth0,data) {
  
  
  return "<div class=\"ebComponentList-separator\"></div>";}

  buffer += "<div class=\"ebComponentList\">\n";
  foundHelper = helpers.items;
  stack1 = foundHelper || depth0.items;
  stack2 = helpers.each;
  tmp1 = self.program(1, program1, data);
  tmp1.hash = {};
  tmp1.fn = tmp1;
  tmp1.inverse = self.noop;
  stack1 = stack2.call(depth0, stack1, tmp1);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>";
  return buffer;});});

/*global define*/
define('widgets/ComponentList/ComponentListView',[
    'jscore/core',
    'template!./_componentList.html',
    'widgets/utils/domUtils'
], function (core, template, domUtils) {
    

    return core.View.extend({

        getTemplate: function () {
            return template(this.options.template);
        },

        getItems: function () {
            return domUtils.findAll('div', this.getElement());
        }

    });

});
/*global define, Object*/
define('widgets/ComponentList/ComponentList',[
    'jscore/core',
    'widgets/WidgetCore',
    './ComponentListView'
], function (core, WidgetCore, View) {
    

    /**
     * The ComponentList class uses the Ericsson brand assets.<br>
     * The ComponentList can be instantiated using the constructor ComponentList.
     *
     * <strong>Constructor:</strong>
     *   <ul>
     *     <li>ComponentList(Object options)</li>
     *   </ul>
     *
     * <strong>Events:</strong>
     *   <ul>
     *     <li>itemSelected: this event is triggered when value is selected in the ComponentList</li>
     *   </ul>
     *
     * <strong>Options:</strong>
     *   <ul>
     *     <li>items: an array used as a list of available items in the ComponentList</li>
     *   </ul>
     *
     * @class ComponentList
     * @extends WidgetCore
     * @beta
     * @private
     */
    return WidgetCore.extend({
        /*jshint validthis:true */

        // TODO : This class needs to use a proper means of accessing the parent.

        view: function() {
            return new View({
                template: {items: this.items}
            });
        },

        /**
         * The init method is automatically called by the constructor when using the "new" operator. If an object with
         * key/value pairs was passed into the constructor then the options variable will have those key/value pairs.
         *
         * @method init
         * @param {Object} options
         * @private
         */
        init: function (options) {
            this._userOffsets = {top: 0, left: 0};
            this.fixedOffset = 6;
            this.selectedItem = {};
            this.options = options || {};
            this.items = this.options.items;
        },

        /**
         * Overrides method from widget.
         * Executes every time, when added back to the screen.
         *
         * @method onViewReady
         * @private
         */
        onViewReady: function () {
            this.view.getItems().forEach(function (itemObj, index) {
                // TODO: If a new type is introduced, then replace this
                if (!(this.items[index].type && this.items[index].type === 'separator')) {
                    itemObj.addEventHandler('click', function (e) {
                        if (e.originalEvent) {
                            e.originalEvent.stopPropagation();
                        }
                        this.onListItemClicked.call(this, index);
                    }, this);
                }
            }, this);

            this.getElement().addEventHandler('itemSelected', function () {
                this.trigger('itemSelected');
                this.hide();
            }, this);

        },

        /**
         * Gets values from the ComponentList
         *
         * @method getItems
         * @return {Array} items
         */
        getItems: function () {
            return this.options.items;
        },

        /**
         * Calculates the position of where the select box should be located relative to the screen.<br>
         * Sets an interval to check if the position changes, and if it does, it's hidden.<br>
         * A body event handler is added to ensure that clicking on the parent element doesn't hide
         * the component list immediately. This can be complex task for developers, so making it easier
         * by just putting it in this method.
         *
         * @method show
         */
        show: function() {
            this.render();
            this.isShowing = true;

            // Create the interval. This interval will check frequently what the current position is suppose to be.
            // If the position changes at all, then the list will disappear.
            if (!this.posInterval) {
                this.posInterval = setInterval(function() {
                    var curPosition = calculatePosition.call(this);
                    if (this.position.top !== curPosition.top || this.position.left !== curPosition.left) {
                        this.hide();
                    }
                }.bind(this), 1000 / 24);
            }

            // Add an event handler to the html element.
            // This handler will check to see if the click target is a child of the parent or the parent itself.
            // If not, this component list is hidden.
            // StopPropagation won't work, because when you click on a different selectbox, you'd want the other
            // one to hide itself automatically. So this approach has to be taken.

            if (!this.options.persistent) {
                var body = core.Element.wrap(document.documentElement);
                if (!this.bodyEventId) {
                    this.bodyEventId = body.addEventHandler('click', function(e) {
                        if (!this.isClickTargetChildOfParent(e)) {
                            body.removeEventHandler(this.bodyEventId);
                            delete this.bodyEventId;
                            this.hide();
                        }
                    }.bind(this));
                }
            }
        },

        /**
         * Adds the offsets to the position of the list.
         *
         * @method setPositionOffsets
         * @param {Object} offsets (top/left)
         */
        setPositionOffsets: function(offsets) {
            this._userOffsets = offsets;
            this.render();
        },

        /**
         * Renders the component list to the screen, and performs some calculations to ensure that the list is not cut
         * off by the viewport.
         *
         * @method render
         */
        render: function() {
            this.getElement().detach();

            // Set the width of the context menu to the width of the parent, unless specified otherwise
            var width = this.options.width || (this.options.parent.getProperty('offsetWidth') + 'px');

            // Calculate the position. We need to keep track of the position for delta purposes
            var position = calculatePosition.call(this);
            this.position = position;

            // Set the style so that we can get the offsets
            this.getElement().setStyle({
                position: 'fixed',
                'display': 'block',
                'top':  position.top + this.options.parent.getProperty('offsetHeight') + this.fixedOffset + 'px',
                'left': position.left + 'px',
                'width': width
            });

            this.options.parent.append(this.getElement());

            // We need to see if the list goes outside screen boundaries. These variables will help.
            var offsetHeight = this.getElement().getProperty('offsetHeight');
            var offsetWidth = this.getElement().getProperty('offsetWidth');
            var screenHeight = document.documentElement.clientHeight;
            var screenWidth = document.documentElement.clientWidth;
            var parentHeight = this.options.parent.getProperty('offsetHeight');

            // If the list goes past the bottom of the screen, flip it to appear above the parent instead of below
            if (position.top + offsetHeight + parentHeight + this.fixedOffset > screenHeight) {
                this.getElement().setStyle({
                    top: position.top - offsetHeight - this.fixedOffset + 'px'
                });
            }

            // If the list goes beyond the right of the viewport, reduce the size of it
            if (position.left + offsetWidth > screenWidth) {
                this.getElement().setStyle({
                    width: (screenWidth - position.left) + 'px'
                });
            }

            // If the list goes beyond the left of the viewport, move it's position, and reduce size
            if (position.left < 0) {
                this.getElement().setStyle({
                    left: 0,
                    width: (offsetWidth + position.left) + 'px'
                });
            }
        },

        /**
         * Iterates up the tree of elements from the target.<br>
         * If it hits the parent, then true is returned.<br>
         * If it runs out of parents, then false is returned.
         *
         * @method isClickTargetChildOfParent
         * @param {Object} e
         * @return {Boolean} isChild
         */
        isClickTargetChildOfParent: function(e) {
            if (e.originalEvent) {
                var obj = e.originalEvent.target || e.originalEvent.srcElement;

                var parent = this.options.parent._getHTMLElement();
                do {
                    if (obj === parent) {
                        return true;
                    }
                } while ((obj = obj.parentElement) !== null && (obj !== document.body));
            }
            return false;
        },

        /**
         * Shows/Hides the list.
         *
         * @method toggle
         */
        toggle: function() {
            this.isShowing = !this.isShowing;
            if (this.isShowing) {
                this.show();
            } else {
                this.hide();
            }
        },

        /**
         * Clears in the interval and detaches the component list from the DOM.
         *
         * @method hide
         */
        hide: function() {
            clearInterval(this.posInterval);
            delete this.posInterval;
            this.getElement().detach();
            this.isShowing = false;
        },


        /**
         * Returns current selected item
         *
         * @method getSelectedValue
         * @return {Object}
         */
        getSelectedValue: function () {
            return this.selectedItem;
        },

        /**
         * An event which is executed when on the list item is clicked
         *
         * @method onListItemClicked
         * @param {int} index
         * @private
         */
        onListItemClicked: function (index) {
            this.selectedItem = this.options.items[index];
            if (this.selectedItem !== null) {
                this.trigger('itemSelected');
                this.hide();
            }
        }

    });

    /**
     * Calculates where the element should appear using the bounding box of the parent element and applying user offsets.
     *
     * TODO: Reimplement this function using property accessors for parent.
     *
     * @method calculatePosition
     * @private
     * @return {Object} top, left
     */
    function calculatePosition() {
        var container = this.options.container || this.options.parent;
        // TODO: Change this to proper DOM function
        var clientRect = container._getHTMLElement().getBoundingClientRect();

        var userOffsets = this._userOffsets || {};
        userOffsets.top = userOffsets.top || 0;
        userOffsets.left = userOffsets.left || 0;

        return {
            top: clientRect.top + userOffsets.top,
            left: clientRect.left + userOffsets.left
        };
    }

});

define('widgets/ComponentList', ['widgets/ComponentList/ComponentList'], function (main) { return main; });
