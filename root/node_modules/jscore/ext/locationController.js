
/**
 * The interfaces package contains a set of abstract interface classes that are extended by the core base classes.
 *
 * @module interfaces
 */
/*global define */
//TODO:write type annotations for variables
define('jscore/interfaces',[], function () {
    
    /**
     *  private method, to make available for tests
     */
    var _private = {};
    /**
     * Underscore each helper
     */
    _private._each = _each;
    function _each(obj, iterator, context) {
        if (obj === null) {
            return;
        }
        if (Array.prototype.forEach && obj.forEach === Array.prototype.forEach) {
            obj.forEach(iterator, context);
        }

    }


    /** Generate Random UID
     *
     * @method guidGenerator
     * @private
     * @return {String}
     * */

    _private.guidGenerator = guidGenerator;
    function guidGenerator() {
        /**
         * @method S4
         * @private
         * @return {String}
         * */
        function S4() {
            /*jshint bitwise: false */
            return  (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        }

        return (S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4() + "-" + new Date().getTime());
    }


    /**
     * Underscore extend helper

     */
    _private._objExtend = _objExtend;
    function _objExtend(obj) {
        _each(Array.prototype.slice.call(arguments, 1), function (source) {
            for (var prop in source) {
                if (prop) {
                    obj[prop] = source[prop];
                }
            }
        });


        return obj;
    }

    /**
     * __extend
     * @param protoProps
     * @param staticProps
     * @returns {*}
     * @private
     */
    _private.__extend = __extend;
    function __extend(protoProps, staticProps) {
        /*jshint validthis:true */
        var parent = this;
        var child;

        if (protoProps && Object.prototype.hasOwnProperty.call(protoProps, 'constructor')) {
            child = protoProps.constructor;
        }
        else {
            child = function () {
                parent.apply(this, arguments);
            };
        }

        _objExtend(child, parent, staticProps);


        var Surrogate = function () {
            this.constructor = child;
        };

        Surrogate.prototype = parent.prototype;
        child.prototype = new Surrogate();

        if (protoProps) {
            _objExtend(child.prototype, protoProps);
        }

        child.__super__ = parent.prototype;

        return child;
    }

    /**
     Add to Context
     */
    _private.__AddtoContext = __AddtoContext;
    function __AddtoContext(context) {
        /*jshint validthis:true */
        this.context = context;

    }

    /**
     *
     * @function createDiv
     * @private
     */
    _private._createDiv = _createDiv;
    function _createDiv() {
        return document.createElement('div');
    }

    /**
     * The App interface represents the main controller of the client application.
     *
     * @class interfaces.App
     */
    function App(options) {
        this.options = options || {};
        if (!this.constructor.prototype.uid) {
            this.constructor.prototype.uid = guidGenerator();
        }

        this.init.apply(this, arguments);
        this.constructor.prototype.counter = this.constructor.prototype.counter || 0;
    }

    App.prototype = {

        /**
         * Implement this method instead of using the View property if some data needs to be pre-processed before the View is instantiated. Note that this method must return an instance of the View.
         *
         * @method view
         * @return {View} view
         * @example
         *    view: function() {
         *     return new View(this.options)
         * }
         */
         
         /**
         * Allows a View to be associated with this object. Must be assigned to the uninitialized View.
         *
         * @property View
         * @type View
         *
         * @example
         *   View: MyView
         */
    
        /**
         * The init method is automatically called by the constructor when using the "new" operator. If an object with
         * key/value pairs is passed into the constructor then the options variable will have those key/value pairs.
         *
         * @param {Object} options
         * @method init
         */
        init: function (options) {
        },

        /**
         * Call this method to start the app.
         *
         * @method start
         * @param {HTMLElement} container
         * @example
         *    app.start();
         */
        start: function (container) {
            if (this.element === undefined) {
                this.context = this.createContext();
                this._createElement();
                this.onStart();
                this._addToContainer(container);
            }
        },

        /**
         * Implement this method to define how to start the app.
         *
         * @method onStart
         * @example
         *    onStart: function() {
		 *     console.log("app started");
		 * }
         */
        onStart: function () {
        },

        /**
         * Call this method stop the App.
         *
         * @method stop
         * @example
         *    app.stop();
         */
        stop: function () {
            if (this.element !== undefined) {
                this._removeFromContainer();
                this.context.destroyAll();
                delete this.context;
                this.onStop();
            }
        },

        /**
         * Implement this method to define how to stop the app.
         *
         * @method onStop
         * @example
         *    onStop: function() {
		 *     console.log("app stopped");
		 * }
         */
        onStop: function () {
        },

        _createElement: function () {
            this.element = _createDiv();
        },

        /**
         * Implement this method to create an AppContext instance.
         *
         * @method createContext
         * @return {AppContext} context
         *
         * @example
         *    createContext: function() {
		 *     return {
         *         myContextFunction: function(){}
         *     }
		 * }
         */
        createContext: function () {
            return new AppContext();
        },

        /**
         * Returns the instance of the AppContext for the App
         *
         * @method getContext
         * @return {AppContext} context
         *
         * @example
         *    app.getContext();
         */
        getContext: function () {
            return this.context;
        },

        /**
         * Appends the app to a native HTMLElement. Used by container.
         *
         * @method _addToContainer
         * @private
         * @param {HTMLElement} container
         */
        _addToContainer: function (container) {
            container.appendChild(this.element);
        },

        /**
         * Removes the app from the container.
         *
         * @method _removeFromContainer
         * @private
         */
        _removeFromContainer: function () {
            this.element.parentNode.removeChild(this.element);
        },

        /**
         * Get the root HTMLElement of the App.
         *
         * @method getElement
         * @return {HTMLElement} element
         *
         * @example
         *    app.getElement();
         */
        getElement: function () {
            return this.element;
        }

    };

    /**
     * To create an App child class call extend providing the class definition.
     *
     * @method extend
     * @static
     * @param {Object} definition
     * @return {App} app
     * @example
     *    interfaces.App.extend({
	 *     onStart: function() {
	 *     }
	 * });
     */
    App.extend = __extend;

    /**
     * The UIComponent interface is implemented by UIComponents such as Regions or Widgets that are managed by the App.
     *
     * @class interfaces.UIComponent
     */
    function UIComponent(options) {
        this.options = options = options || {};
        this.uid = guidGenerator();

        if (options.context) {
            __AddtoContext.call(this, options.context);
            delete options.context;
        }
        this.init.apply(this, arguments);
        this._afterInit.apply(this, arguments);

    }

    UIComponent.prototype = {
    
        _afterInit:function(options){

        },
    
        /**
         * Implement this method instead of using the View property if some data needs to be pre-processed before the View is instantiated. Note that this method must return an instance of the View.
         *
         * @method view
         * @return {View} view
         * @example
         *    view: function() {
         *     return new View(this.options);    
         * }
         */
         
         /**
         * Allows a View to be associated with this object. Must be assigned to the uninitialized View.
         *
         * @property View
         * @type View
         *
         * @example
         *   View: MyView
         */

        /**
         * The init method is automatically called by the constructor when using the "new" operator. If an object with
         * key/value pairs is passed into the constructor then the options variable will have those key/value pairs.
         *
         * @method init
         * @param options
         */
        init: function (options) {
        },

        /**
         * Sets the root element of the UIComponent.
         *
         * @method setElement
         * @private
         * @param {HTMLElement} element
         */
        setElement: function (element) {
            this.element = element;
        },
        _createElement: function () {
            this.element = _createDiv();
        },
        /**
         * Get the root HTMLElement of the UIComponent.
         *
         * @method getElement
         * @return {HTMLElement} element
         * @example
         *    uicomponent.getElement();
         */
        getElement: function () {
            return this.element;
        },
        destroy: function () {
            var element = this.getElement();
            element.parentNode.removeChild(element);

        }
    };

    /**
     * To create an UIComponent child class call extend providing the class definition.
     *
     * @method extend
     * @static
     * @param {Object} definition
     * @return {UIComponent} component
     * @example
     *    interfaces.UIComponent.extend({
	 *     init: function() {
	 *     }
	 * });
     */
    UIComponent.extend = __extend;


    /**
     * The AppContext interface represents a utility that the App uses to share a common context between Regions using the sandbox pattern.
     *
     * @class interfaces.AppContext
     */
    function AppContext() {
        this.uid = guidGenerator();
        this._components = {};
        this.init.apply(this, arguments);
    }

    //TODO: need implement method to Remove Specific Component
    AppContext.prototype = {

        /**
         * The init method is automatically called by the constructor when using the "new" operator. If an object with
         * key/value pairs is passed into the constructor then the options variable will have those key/value pairs.
         *
         * @method init
         * @param options
         */
        init: function (options) {
        },

        /**
         * Destroy all registered components.
         *
         * @method destroyAll
         * @private
         */
        destroyAll: function () {
            var components = this._components;
            Object.keys(components).forEach(function (key) {
                components[key].destroy();

            });
        }
    };

    /**
     * To create an AppContext child class call extend providing the class definition.
     *
     * @method extend
     * @static
     * @param {Object} definition
     * @return {AppContext} context
     */
    AppContext.extend = __extend;


    return {
        App: App,
        UIComponent: UIComponent,
        AppContext: AppContext,
        extend: __extend,
        _private: _private
    };
});

/*global define*/
define('jscore/ext/locationController',[
    '../core'
], function (core) {
    

    function guidGenerator() {
        /**
         * @method S4
         * @private
         * @return {String}
         * */
        function S4() {
            /*jshint bitwise: false */
            return  (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        }

        return (S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4() + "-" + new Date().getTime());
    }

    /**
     * LocationController is a utility object that manages events based on the hash value of the URL.
     *
     * @class ext.LocationController
     */
    function LocationController(options) {
        this.handlers = {};
        this.options = options;
        this._preventListeners = false;
        this.init.apply(this, arguments);
        if (options && options.namespace) {
            this.namespace = options.namespace;
        }
    }

    LocationController.prototype = {

        /**
         * If defined, location listeners will not execute their handlers unless the hash starts with this namespace, and the hash variable in the callback function will not have the namespace included.
         *
         * @property namespace
         * @type String
         */

        /**
         * If extending the LocationController, you can override this function, which is automatically called when the extended LocationController is instantiated.
         *
         * @method init
         * @param {Object} options
         *
         * @example
         * init: function(options) {
         *     // some initialisation here
         * }
         */
        init: function(options) {
        },

        /**
         * Gets the string after the hash value in the URL.
         *
         * @method getLocation
         * @return {String} location
         *
         * @example
         *    lc.getLocation();
         */
        getLocation: function () {
            var hash = window.location.hash;
            var decodedURI = decodeURIComponent(hash); // TODO: Figure out how to allow % as a special character in Firefox.
            if (decodedURI.charAt(0) === '#') {
                decodedURI = decodedURI.substr(1);
            }
            return decodedURI;
        },

        /**
         * Gets the string after the hash value after the namespace in the URL. If the namespace was set to "MyNamespace", and the current hash value in the url is "#MyNamespace/somePage/1", then this function will return "somePage/1".
         *
         * @method getNamespaceLocation
         * @return {String} location
         *
         * @example
         *    lc.getNamespaceLocation();
         */
        getNamespaceLocation: function() {
            var location = this.getLocation();
            if (this.namespace) {
                location = location.substring(this.namespace.length + 1);
            }
            return location;
        },

        /**
         * Sets the string after the hash in the URL. If preventListeners is true, Location Listeners will not trigger when the hash is set.
         *
         * @method setLocation
         * @param {String} location
         * @param {Boolean} preventListeners
         * @example
         *    lc.setLocation("some/location");
         */
        setLocation: function (location, preventListeners) {
            if (preventListeners) {
                this._preventListeners = true;
            } else {
                this._preventListeners = false;
            }
            window.location.hash = location;
        },

        /**
         * Sets the string after the namespace in the hash in the URL. If the namespace was set to "MyNamespace", and the parameter was "somePage/1", then the hash value in the url will be set to "#MyNamespace/somePage/1". If preventListeners is true, Location Listeners will not trigger when the hash is set.
         *
         * @method setNamespaceLocation
         * @param {String} location
         * @param {Boolean} preventListeners
         *
         * @example
         *    lc.setNamespaceLocation("some/location");
         */
        setNamespaceLocation: function(location, preventListeners) {
            if (this.namespace) {
                location = this.namespace + "/" + location;
            }
            this.setLocation(location, preventListeners);
        },

        /**
         * Adds an event handler that executes when the URL hash value changes. The hash value is equal to the string after the hash in the URL. If a namespace was specified in the constructor or as a property, then the hash value will be equal to the string after the slash after the namespace.
         *
         * @method addLocationListener
         * @param {Function} fn
         * @param {Object} [context]
         * @return {String} id
         * @example
         * lc.addLocationListener(function(hash) {
         *     if (hash == "some/location") {
         *         console.log("url is set to some/location");
         *     }
         * });
         */
        addLocationListener: function (fn, context) {
            var id = guidGenerator();
            this.handlers[id] = context ? fn.bind(context) : fn;
            return id;
        },

        /**
         * Removes an event handler previously added by addLocationListener.
         *
         * @method removeLocationListener
         * @param {String} id
         */
        removeLocationListener: function (id) {
            delete this.handlers[id];
        },

        /**
         * Starts listening for changes to the hash value in the URL. It will also check the hash immediately and execute existing handlers.
         *
         * @method start
         * @example
         *    lc.start();
         */
        start: function () {
            this._execHandlers();
            this._startListening();
        },
        _execHandlers: function () {
            if (!this._preventListeners) {
                 var hash = this.getLocation();
                if (hash === this.currentUrl) return;
                this.currentUrl = hash;
                var regExp = new RegExp("^"+this.namespace+"(?![a-zA-Z0-9])", "i");
                if ((this.namespace && regExp.test(hash)) ||
                    !this.namespace) {
                    if (this.namespace) {
                        hash = hash.substring(this.namespace.length + 1);
                    }
                    for (var key in this.handlers) {
                        if (this.handlers.hasOwnProperty(key)) {
                            this.handlers[key](hash);
                        }
                    }
                }
            } else {
                this._preventListeners = false;
            }

        },
        _startListening: function () {
            this.listener = this._execHandlers.bind(this);
            window.addEventListener("hashchange", this.listener);
        },

        /**
         * Stops listening for changes to the hash value in the URL.
         *
         * @method stop
         */
        stop: function () {
            delete this.currentUrl;
            window.removeEventListener('hashchange', this.listener);
        }
    };

    /**
     * To create a LocationController child class call extend providing the class definition.
     *
     * @method extend
     * @static
     * @param {Object} definition
     * @return {LocationController} locationController
     *
     * @example
     * LocationController.extend({
	 *     init: function() {
	 *         console.log("Hello LocationController!");
	 *     }
	 * });
     */
    LocationController.extend = core.extend;
    return LocationController;
});
