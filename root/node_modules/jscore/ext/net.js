
/**
 * The interfaces package contains a set of abstract interface classes that are extended by the core base classes.
 *
 * @module interfaces
 */
/*global define */
//TODO:write type annotations for variables
define('jscore/interfaces',[], function () {
    
    /**
     *  private method, to make available for tests
     */
    var _private = {};
    /**
     * Underscore each helper
     */
    _private._each = _each;
    function _each(obj, iterator, context) {
        if (obj === null) {
            return;
        }
        if (Array.prototype.forEach && obj.forEach === Array.prototype.forEach) {
            obj.forEach(iterator, context);
        }

    }


    /** Generate Random UID
     *
     * @method guidGenerator
     * @private
     * @return {String}
     * */

    _private.guidGenerator = guidGenerator;
    function guidGenerator() {
        /**
         * @method S4
         * @private
         * @return {String}
         * */
        function S4() {
            /*jshint bitwise: false */
            return  (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        }

        return (S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4() + "-" + new Date().getTime());
    }


    /**
     * Underscore extend helper

     */
    _private._objExtend = _objExtend;
    function _objExtend(obj) {
        _each(Array.prototype.slice.call(arguments, 1), function (source) {
            for (var prop in source) {
                if (prop) {
                    obj[prop] = source[prop];
                }
            }
        });


        return obj;
    }

    /**
     * __extend
     * @param protoProps
     * @param staticProps
     * @returns {*}
     * @private
     */
    _private.__extend = __extend;
    function __extend(protoProps, staticProps) {
        /*jshint validthis:true */
        var parent = this;
        var child;

        if (protoProps && Object.prototype.hasOwnProperty.call(protoProps, 'constructor')) {
            child = protoProps.constructor;
        }
        else {
            child = function () {
                parent.apply(this, arguments);
            };
        }

        _objExtend(child, parent, staticProps);


        var Surrogate = function () {
            this.constructor = child;
        };

        Surrogate.prototype = parent.prototype;
        child.prototype = new Surrogate();

        if (protoProps) {
            _objExtend(child.prototype, protoProps);
        }

        child.__super__ = parent.prototype;

        return child;
    }

    /**
     Add to Context
     */
    _private.__AddtoContext = __AddtoContext;
    function __AddtoContext(context) {
        /*jshint validthis:true */
        this.context = context;

    }

    /**
     *
     * @function createDiv
     * @private
     */
    _private._createDiv = _createDiv;
    function _createDiv() {
        return document.createElement('div');
    }

    /**
     * The App interface represents the main controller of the client application.
     *
     * @class interfaces.App
     */
    function App(options) {
        this.options = options || {};
        if (!this.constructor.prototype.uid) {
            this.constructor.prototype.uid = guidGenerator();
        }

        this.init.apply(this, arguments);
        this.constructor.prototype.counter = this.constructor.prototype.counter || 0;
    }

    App.prototype = {

        /**
         * Implement this method instead of using the View property if some data needs to be pre-processed before the View is instantiated. Note that this method must return an instance of the View.
         *
         * @method view
         * @return {View} view
         * @example
         *    view: function() {
         *     return new View(this.options)
         * }
         */
         
         /**
         * Allows a View to be associated with this object. Must be assigned to the uninitialized View.
         *
         * @property View
         * @type View
         *
         * @example
         *   View: MyView
         */
    
        /**
         * The init method is automatically called by the constructor when using the "new" operator. If an object with
         * key/value pairs is passed into the constructor then the options variable will have those key/value pairs.
         *
         * @param {Object} options
         * @method init
         */
        init: function (options) {
        },

        /**
         * Call this method to start the app.
         *
         * @method start
         * @param {HTMLElement} container
         * @example
         *    app.start();
         */
        start: function (container) {
            if (this.element === undefined) {
                this.context = this.createContext();
                this._createElement();
                this.onStart();
                this._addToContainer(container);
            }
        },

        /**
         * Implement this method to define how to start the app.
         *
         * @method onStart
         * @example
         *    onStart: function() {
		 *     console.log("app started");
		 * }
         */
        onStart: function () {
        },

        /**
         * Call this method stop the App.
         *
         * @method stop
         * @example
         *    app.stop();
         */
        stop: function () {
            if (this.element !== undefined) {
                this._removeFromContainer();
                this.context.destroyAll();
                delete this.context;
                this.onStop();
            }
        },

        /**
         * Implement this method to define how to stop the app.
         *
         * @method onStop
         * @example
         *    onStop: function() {
		 *     console.log("app stopped");
		 * }
         */
        onStop: function () {
        },

        _createElement: function () {
            this.element = _createDiv();
        },

        /**
         * Implement this method to create an AppContext instance.
         *
         * @method createContext
         * @return {AppContext} context
         *
         * @example
         *    createContext: function() {
		 *     return {
         *         myContextFunction: function(){}
         *     }
		 * }
         */
        createContext: function () {
            return new AppContext();
        },

        /**
         * Returns the instance of the AppContext for the App
         *
         * @method getContext
         * @return {AppContext} context
         *
         * @example
         *    app.getContext();
         */
        getContext: function () {
            return this.context;
        },

        /**
         * Appends the app to a native HTMLElement. Used by container.
         *
         * @method _addToContainer
         * @private
         * @param {HTMLElement} container
         */
        _addToContainer: function (container) {
            container.appendChild(this.element);
        },

        /**
         * Removes the app from the container.
         *
         * @method _removeFromContainer
         * @private
         */
        _removeFromContainer: function () {
            this.element.parentNode.removeChild(this.element);
        },

        /**
         * Get the root HTMLElement of the App.
         *
         * @method getElement
         * @return {HTMLElement} element
         *
         * @example
         *    app.getElement();
         */
        getElement: function () {
            return this.element;
        }

    };

    /**
     * To create an App child class call extend providing the class definition.
     *
     * @method extend
     * @static
     * @param {Object} definition
     * @return {App} app
     * @example
     *    interfaces.App.extend({
	 *     onStart: function() {
	 *     }
	 * });
     */
    App.extend = __extend;

    /**
     * The UIComponent interface is implemented by UIComponents such as Regions or Widgets that are managed by the App.
     *
     * @class interfaces.UIComponent
     */
    function UIComponent(options) {
        this.options = options = options || {};
        this.uid = guidGenerator();

        if (options.context) {
            __AddtoContext.call(this, options.context);
            delete options.context;
        }
        this.init.apply(this, arguments);
        this._afterInit.apply(this, arguments);

    }

    UIComponent.prototype = {
    
        _afterInit:function(options){

        },
    
        /**
         * Implement this method instead of using the View property if some data needs to be pre-processed before the View is instantiated. Note that this method must return an instance of the View.
         *
         * @method view
         * @return {View} view
         * @example
         *    view: function() {
         *     return new View(this.options);    
         * }
         */
         
         /**
         * Allows a View to be associated with this object. Must be assigned to the uninitialized View.
         *
         * @property View
         * @type View
         *
         * @example
         *   View: MyView
         */

        /**
         * The init method is automatically called by the constructor when using the "new" operator. If an object with
         * key/value pairs is passed into the constructor then the options variable will have those key/value pairs.
         *
         * @method init
         * @param options
         */
        init: function (options) {
        },

        /**
         * Sets the root element of the UIComponent.
         *
         * @method setElement
         * @private
         * @param {HTMLElement} element
         */
        setElement: function (element) {
            this.element = element;
        },
        _createElement: function () {
            this.element = _createDiv();
        },
        /**
         * Get the root HTMLElement of the UIComponent.
         *
         * @method getElement
         * @return {HTMLElement} element
         * @example
         *    uicomponent.getElement();
         */
        getElement: function () {
            return this.element;
        },
        destroy: function () {
            var element = this.getElement();
            element.parentNode.removeChild(element);

        }
    };

    /**
     * To create an UIComponent child class call extend providing the class definition.
     *
     * @method extend
     * @static
     * @param {Object} definition
     * @return {UIComponent} component
     * @example
     *    interfaces.UIComponent.extend({
	 *     init: function() {
	 *     }
	 * });
     */
    UIComponent.extend = __extend;


    /**
     * The AppContext interface represents a utility that the App uses to share a common context between Regions using the sandbox pattern.
     *
     * @class interfaces.AppContext
     */
    function AppContext() {
        this.uid = guidGenerator();
        this._components = {};
        this.init.apply(this, arguments);
    }

    //TODO: need implement method to Remove Specific Component
    AppContext.prototype = {

        /**
         * The init method is automatically called by the constructor when using the "new" operator. If an object with
         * key/value pairs is passed into the constructor then the options variable will have those key/value pairs.
         *
         * @method init
         * @param options
         */
        init: function (options) {
        },

        /**
         * Destroy all registered components.
         *
         * @method destroyAll
         * @private
         */
        destroyAll: function () {
            var components = this._components;
            Object.keys(components).forEach(function (key) {
                components[key].destroy();

            });
        }
    };

    /**
     * To create an AppContext child class call extend providing the class definition.
     *
     * @method extend
     * @static
     * @param {Object} definition
     * @return {AppContext} context
     */
    AppContext.extend = __extend;


    return {
        App: App,
        UIComponent: UIComponent,
        AppContext: AppContext,
        extend: __extend,
        _private: _private
    };
});

/*globals define */
define('jscore/ext/net',[
    'jscore/core',
    "jscore/base/jquery",
    "jscore/ext/utils/base/underscore"
], function(core, jquery, _) {
    
    /**
     * The ext.net package provides networking functionality for JSCore apps.
     *
     * @class ext.net
     */
    var net = {};

    /**
     * Creates an XMLHttpRequest. Default values are used where none is provided.
     *
     * The following options are accepted:
     *   <ul>
     *       <li>url (String): url for the request to be sent to.</li>
     *       <li>type (String): Type of request. GET [default], POST, DELETE, PUT.</li>
     *       <li>data (Object): Key value pairs that is encoded and sent to the url.</li>
     *       <li>dataType (String): Type of data being passed into success callback. text [default], json, xml.</li>
     *       <li>headers (Object): Additional key/value pair of headers to send with the request.</li>
     *       <li>contentType (String/Boolean): Type of data being sent to url. Default is "application/x-www-form-urlencoded; charset=UTF-8". Set to false to not append a content type header.</li>
     *       <li>statusCode (Object): Key is HTTP code, value is function. Functions execute depending on response.</li>
     *       <li>processData (Boolean): Convert data object to query string before sending to url. Default is true.</li>
     *       <li>cache (Boolean): If set to false, requested urls will not be cached for GET requests (appends a timestamp to the url to prevent caching). Default is true.</li>
     *       <li>success (Function): Callback with data response passed in.</li>
     *       <li>error (Function): Callback if error occurs with error message passed in.</li>
     *   </ul>
     *
     * @method ajax
     * @param options
     * @return {XHR} xhr
     * @example
     * net.ajax({
     *     url: "/todos",
     *     type: "GET",
     *     dataType: "json",
     *     success: function(data) {
     *         console.log(data);
     *     },
     *     error: function(msg) {
     *         console.error("Error: " + msg);
     *     }
     * })
     *
     * net.ajax({
     *     url: "/todos",
     *     type: "POST",
     *     contentType: "application/json",
     *     data: JSON.stringify({message: "Hello World"})
     * });
     *
     * var data = new FormData();
     * data.append(input.getProperty("files")[0]);
     * net.ajax({
     *     url: "/upload.php",
     *     type: "POST",
     *     contentType: false,
     *     processData: false,
     *     data: data,
     *     success: function(data) {
     *         console.log(data);
     *     }
     * });
     */
	net.ajax = function(options) {
        options = options || {};
		var wrappedSuccess = function(data) {
			if (options.success) {
				options.success.call(this, data);
			}
		};

		var wrappedError = function(jqXHR, textStatus, errorThrown) {
			if (options.error) {
				options.error.call(this, errorThrown);
            }
		};

        var ajaxOptions = {
            success: wrappedSuccess,
            error: wrappedError,
            type: "GET",
            dataType: "text",
            url: window.location.host + window.location.pathname
        };

        _.extend(ajaxOptions,
            _.pick(options, "statusCode", "processData", "cache", "data", "contentType", "dataType", "type", "url", "headers"));

        var jqxhr = jquery.ajax(ajaxOptions);
        return new core.XHR(jqxhr);
    };

	return net;

});
