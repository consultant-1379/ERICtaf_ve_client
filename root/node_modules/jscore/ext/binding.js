
/**
 * The interfaces package contains a set of abstract interface classes that are extended by the core base classes.
 *
 * @module interfaces
 */
/*global define */
//TODO:write type annotations for variables
define('jscore/interfaces',[], function () {
    
    /**
     *  private method, to make available for tests
     */
    var _private = {};
    /**
     * Underscore each helper
     */
    _private._each = _each;
    function _each(obj, iterator, context) {
        if (obj === null) {
            return;
        }
        if (Array.prototype.forEach && obj.forEach === Array.prototype.forEach) {
            obj.forEach(iterator, context);
        }

    }


    /** Generate Random UID
     *
     * @method guidGenerator
     * @private
     * @return {String}
     * */

    _private.guidGenerator = guidGenerator;
    function guidGenerator() {
        /**
         * @method S4
         * @private
         * @return {String}
         * */
        function S4() {
            /*jshint bitwise: false */
            return  (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        }

        return (S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4() + "-" + new Date().getTime());
    }


    /**
     * Underscore extend helper

     */
    _private._objExtend = _objExtend;
    function _objExtend(obj) {
        _each(Array.prototype.slice.call(arguments, 1), function (source) {
            for (var prop in source) {
                if (prop) {
                    obj[prop] = source[prop];
                }
            }
        });


        return obj;
    }

    /**
     * __extend
     * @param protoProps
     * @param staticProps
     * @returns {*}
     * @private
     */
    _private.__extend = __extend;
    function __extend(protoProps, staticProps) {
        /*jshint validthis:true */
        var parent = this;
        var child;

        if (protoProps && Object.prototype.hasOwnProperty.call(protoProps, 'constructor')) {
            child = protoProps.constructor;
        }
        else {
            child = function () {
                parent.apply(this, arguments);
            };
        }

        _objExtend(child, parent, staticProps);


        var Surrogate = function () {
            this.constructor = child;
        };

        Surrogate.prototype = parent.prototype;
        child.prototype = new Surrogate();

        if (protoProps) {
            _objExtend(child.prototype, protoProps);
        }

        child.__super__ = parent.prototype;

        return child;
    }

    /**
     Add to Context
     */
    _private.__AddtoContext = __AddtoContext;
    function __AddtoContext(context) {
        /*jshint validthis:true */
        this.context = context;

    }

    /**
     *
     * @function createDiv
     * @private
     */
    _private._createDiv = _createDiv;
    function _createDiv() {
        return document.createElement('div');
    }

    /**
     * The App interface represents the main controller of the client application.
     *
     * @class interfaces.App
     */
    function App(options) {
        this.options = options || {};
        if (!this.constructor.prototype.uid) {
            this.constructor.prototype.uid = guidGenerator();
        }

        this.init.apply(this, arguments);
        this.constructor.prototype.counter = this.constructor.prototype.counter || 0;
    }

    App.prototype = {

        /**
         * Implement this method instead of using the View property if some data needs to be pre-processed before the View is instantiated. Note that this method must return an instance of the View.
         *
         * @method view
         * @return {View} view
         * @example
         *    view: function() {
         *     return new View(this.options)
         * }
         */
         
         /**
         * Allows a View to be associated with this object. Must be assigned to the uninitialized View.
         *
         * @property View
         * @type View
         *
         * @example
         *   View: MyView
         */
    
        /**
         * The init method is automatically called by the constructor when using the "new" operator. If an object with
         * key/value pairs is passed into the constructor then the options variable will have those key/value pairs.
         *
         * @param {Object} options
         * @method init
         */
        init: function (options) {
        },

        /**
         * Call this method to start the app.
         *
         * @method start
         * @param {HTMLElement} container
         * @example
         *    app.start();
         */
        start: function (container) {
            if (this.element === undefined) {
                this.context = this.createContext();
                this._createElement();
                this.onStart();
                this._addToContainer(container);
            }
        },

        /**
         * Implement this method to define how to start the app.
         *
         * @method onStart
         * @example
         *    onStart: function() {
		 *     console.log("app started");
		 * }
         */
        onStart: function () {
        },

        /**
         * Call this method stop the App.
         *
         * @method stop
         * @example
         *    app.stop();
         */
        stop: function () {
            if (this.element !== undefined) {
                this._removeFromContainer();
                this.context.destroyAll();
                delete this.context;
                this.onStop();
            }
        },

        /**
         * Implement this method to define how to stop the app.
         *
         * @method onStop
         * @example
         *    onStop: function() {
		 *     console.log("app stopped");
		 * }
         */
        onStop: function () {
        },

        _createElement: function () {
            this.element = _createDiv();
        },

        /**
         * Implement this method to create an AppContext instance.
         *
         * @method createContext
         * @return {AppContext} context
         *
         * @example
         *    createContext: function() {
		 *     return {
         *         myContextFunction: function(){}
         *     }
		 * }
         */
        createContext: function () {
            return new AppContext();
        },

        /**
         * Returns the instance of the AppContext for the App
         *
         * @method getContext
         * @return {AppContext} context
         *
         * @example
         *    app.getContext();
         */
        getContext: function () {
            return this.context;
        },

        /**
         * Appends the app to a native HTMLElement. Used by container.
         *
         * @method _addToContainer
         * @private
         * @param {HTMLElement} container
         */
        _addToContainer: function (container) {
            container.appendChild(this.element);
        },

        /**
         * Removes the app from the container.
         *
         * @method _removeFromContainer
         * @private
         */
        _removeFromContainer: function () {
            this.element.parentNode.removeChild(this.element);
        },

        /**
         * Get the root HTMLElement of the App.
         *
         * @method getElement
         * @return {HTMLElement} element
         *
         * @example
         *    app.getElement();
         */
        getElement: function () {
            return this.element;
        }

    };

    /**
     * To create an App child class call extend providing the class definition.
     *
     * @method extend
     * @static
     * @param {Object} definition
     * @return {App} app
     * @example
     *    interfaces.App.extend({
	 *     onStart: function() {
	 *     }
	 * });
     */
    App.extend = __extend;

    /**
     * The UIComponent interface is implemented by UIComponents such as Regions or Widgets that are managed by the App.
     *
     * @class interfaces.UIComponent
     */
    function UIComponent(options) {
        this.options = options = options || {};
        this.uid = guidGenerator();

        if (options.context) {
            __AddtoContext.call(this, options.context);
            delete options.context;
        }
        this.init.apply(this, arguments);
        this._afterInit.apply(this, arguments);

    }

    UIComponent.prototype = {
    
        _afterInit:function(options){

        },
    
        /**
         * Implement this method instead of using the View property if some data needs to be pre-processed before the View is instantiated. Note that this method must return an instance of the View.
         *
         * @method view
         * @return {View} view
         * @example
         *    view: function() {
         *     return new View(this.options);    
         * }
         */
         
         /**
         * Allows a View to be associated with this object. Must be assigned to the uninitialized View.
         *
         * @property View
         * @type View
         *
         * @example
         *   View: MyView
         */

        /**
         * The init method is automatically called by the constructor when using the "new" operator. If an object with
         * key/value pairs is passed into the constructor then the options variable will have those key/value pairs.
         *
         * @method init
         * @param options
         */
        init: function (options) {
        },

        /**
         * Sets the root element of the UIComponent.
         *
         * @method setElement
         * @private
         * @param {HTMLElement} element
         */
        setElement: function (element) {
            this.element = element;
        },
        _createElement: function () {
            this.element = _createDiv();
        },
        /**
         * Get the root HTMLElement of the UIComponent.
         *
         * @method getElement
         * @return {HTMLElement} element
         * @example
         *    uicomponent.getElement();
         */
        getElement: function () {
            return this.element;
        },
        destroy: function () {
            var element = this.getElement();
            element.parentNode.removeChild(element);

        }
    };

    /**
     * To create an UIComponent child class call extend providing the class definition.
     *
     * @method extend
     * @static
     * @param {Object} definition
     * @return {UIComponent} component
     * @example
     *    interfaces.UIComponent.extend({
	 *     init: function() {
	 *     }
	 * });
     */
    UIComponent.extend = __extend;


    /**
     * The AppContext interface represents a utility that the App uses to share a common context between Regions using the sandbox pattern.
     *
     * @class interfaces.AppContext
     */
    function AppContext() {
        this.uid = guidGenerator();
        this._components = {};
        this.init.apply(this, arguments);
    }

    //TODO: need implement method to Remove Specific Component
    AppContext.prototype = {

        /**
         * The init method is automatically called by the constructor when using the "new" operator. If an object with
         * key/value pairs is passed into the constructor then the options variable will have those key/value pairs.
         *
         * @method init
         * @param options
         */
        init: function (options) {
        },

        /**
         * Destroy all registered components.
         *
         * @method destroyAll
         * @private
         */
        destroyAll: function () {
            var components = this._components;
            Object.keys(components).forEach(function (key) {
                components[key].destroy();

            });
        }
    };

    /**
     * To create an AppContext child class call extend providing the class definition.
     *
     * @method extend
     * @static
     * @param {Object} definition
     * @return {AppContext} context
     */
    AppContext.extend = __extend;


    return {
        App: App,
        UIComponent: UIComponent,
        AppContext: AppContext,
        extend: __extend,
        _private: _private
    };
});

/*globals define */
define('jscore/ext/binding',[
    'jscore/core',
    'jscore/ext/utils/base/underscore'
], function (core, _) {

    /**
     * Observable represents a value changing over time. The main difference from a typical variable is that you can be notified every time it changes.
     */
    var Observable = function (subscribe) {
        this.subscribe = subscribe;
    };

    Observable.extend = core.extend;

    Observable.prototype = {
        map: function (fn) {
            return new Observable(function (subscriber) {
                this.subscribe(function (val) {
                    subscriber(fn(val));
                });
            }.bind(this));
        }
    };

    /**
     * Creates Observable from an event target and event name. Event target can be any object with addEventHandler method, such as Widget or Model. Subscribers will be called every time a new event is emitted.
     *
     * @private
     * @method eventTargetObservable
     * @param {Object} target
     * @param {String} eventName
     * @returns {Observable} observable
     */
    var eventTargetObservable = function (target, eventName) {
        return new Observable(function (subscriber) {
            target.addEventHandler(eventName, subscriber);
        });
    };

    var Bindable = Observable.extend({

        /**
         * Bindable is a value changing over time which can also be bound to another value, so that they stay in sync.
         *
         * The following options are accepted:
         *   <ul>
         *       <li>get: a function which should return current value this object is wrapping.</li>
         *       <li>set: a function which should set wrapped object's value to the one provided in the first argument.</li>
         *       <li>events: an Observable this bindable will be subscribed to. Every time event is emitted, bindable will get the new value using get method and inform its listeners that the value has been changed.</li>
         *   </ul>
         *
         * //@class ext.binding.Bindable
         * @constructor
         * @param {Object} options
         */
        constructor: function (options) {
            this.subscribers = [];
            this.options = options;
            if (options.events && options.get) {
                this.events = options.events.map(options.get);
                this.trigger(options.get());
                this.events.subscribe(this.trigger.bind(this));
            } else {
                this.events = new Observable(function () {});
            }
        },

        subscribe: function (subscriber) {
            if (_.isFunction(subscriber)) {
                this.events.subscribe(subscriber);
            } else {
                this.subscribers.push(subscriber);
                if (this.value !== undefined) {
                    subscriber.fn(this.value);
                }
            }
        },

        addSyncSource: function (source) {
            source.subscribe({
                source: this,
                fn: function (value) {
                    this.value = value;
                    if (this.options.set) {
                        this.options.set(value);
                    }
                    this.notifyExcept(source);
                }.bind(this)
            });
        },

        trigger: function (newValue) {
            if (this.value !== newValue) {
                this.value = newValue;
                this.notifyExcept();
            }
        },

        notifyExcept: function (ignoredSubscriber) {
            for (var i in this.subscribers) {
                var subscriber = this.subscribers[i];
                if (subscriber.source === ignoredSubscriber) {
                    continue;
                }
                subscriber.fn(this.value);
            }
        },

        /**
         * Binds current object to another Bindable, so that their values stay in sync.
         *
         * @private
         * @method bind
         * @param {Bindable} other
         *
         */
        bind: function (other) {
            other.addSyncSource(this);
            this.addSyncSource(other);
        }
    });

    function modelAttribute (model, attribute) {
        return new Bindable({
            get: function () { return model.get(attribute); },
            set: function (val) { return model.set(attribute, val); },
            events: eventTargetObservable(model, 'change:' + attribute)
        });
    }

    var bindings = {
        text: function (el) {
            return new Bindable({
                set: el.setText.bind(el)
            });
        },

        value: function (el) {
            return new Bindable({
                get: el.getValue.bind(el),
                set: el.setValue.bind(el),
                events: eventTargetObservable(el, 'focusOut change paste cut input')
            });
        }
    };

    /**
     * The ext.binding object provides the ability to bind models to views declaratively.
     * See the {{#crossLink "ext.binding/bind:method"}}{{/crossLink}} method documentation for more details.
     *
     * @class ext.binding
     * @static
     */
    var binding = {
        /**
         * Establishes a two-way binding between model's attribute and a view element according to the binding type. Binding type defines how the data should be bound to the element. The following types are supported:
         * <ul>
         *   <li><strong>text</strong> - binds data to the inner text of an element.</li>
         *   <li><strong>value</strong> - binds data to the value attribute of an input element.</li>
         * </ul>
         *
         * @method bind
         * @static
         * @param {Model} model
         * @param {String} attribute
         * @param {Element} element
         * @param {String} bindingType
         * @example
         *      binding.bindModel(model, 'firstName', element.find('.eaMyApp-MyRegion-firstNameInput'), 'text');
         */
        bindModel: function (model, attribute, element, type) {
            var attributeObservable = modelAttribute(model, attribute);
            var binding = _.isFunction(type) ? type : bindings[type];
            var elementObservable = binding(element);
            attributeObservable.bind(elementObservable);
        },

        /**
         * Renders supplied collection in the placeholderElement and keeps the two in sync. newWidgetCallback will be called for every model and should return a new Widget. Every change in the collection will be reflected in DOM. Pelase bear in mind that changes to the models themselves should be taken care of by the widget returned by newWidgetCallback function.
         * Returns function which you can use to stop binding. This will also empty the placeholderElement.
         *
         * @private
         * @method bindCollection
         * @static
         * @param {Collection} collection
         * @param {Element} placeholderElement
         * @param {Function} createWidgetFunction
         * @return {Function} unbindFunction
         * @example
         *   binding.binbindCollection(collection, this.getElement(), function (model) {
         *       return new MyWidget({model: model});
         *  });
         */
        bindCollection: function (collection, placeholderElement, newWidgetCallback) {
            var _events = {};
            var _models = {};

            var addModel = function (model) {
                var widget = _models[model.cid];
                if (!widget) {
                    widget = newWidgetCallback(model);
                    _models[model.cid] = widget;
                }
                widget.attachTo(placeholderElement);
            };

            var addAll = function () {
                collection.each(addModel);
            };

            var removeModel = function (model) {
                _models[model.cid].destroy();
                delete _models[model.cid];
            };

            var removeAll = function () {
                for (var cid in _models) {
                    _models[cid].destroy();
                    delete _models[cid];
                }
            };

            addAll();

            _events.add = collection.addEventHandler("add", addModel);
            _events.remove = collection.addEventHandler("remove", removeModel);
            _events.reset = collection.addEventHandler("reset", function () {
                setData(collection);
            });
            _events.sort = collection.addEventHandler("sort", function () {
                for (var cid in _models) {
                    _models[cid].detach();
                }
                addAll();
            });

            return function () {
                for (var event in _events) {
                    collection.removeEventHandler(event, _events[event]);
                }
                removeAll();
            };
        },

        Bindable: Bindable,
        modelAttribute: modelAttribute,

        /**
         * Wraps an input element into Bindable. Subscribers are going to be notified on every input modification, while external events will update input element value.
         *
         * @private
         * @method value
         * @static
         */
        value: bindings.value,

        /**
         * Wraps an element text content into Bindable. The bindable of this type doesn't emit any events, but will respond to external events by updating text content.
         *
         * @private
         * @method text
         * @static
         */
        text: bindings.text,


        eventTargetObservable: eventTargetObservable
    };

    binding.bind = binding.bindModel;

    return binding;

});
